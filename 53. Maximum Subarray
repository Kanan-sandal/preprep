Optimal Approach (Kadane’s Algorithm)
Idea:
Maintain currentSum = max sum ending at current index
Maintain maxSum = maximum sum seen so far
Update: currentSum = max(nums[i], currentSum + nums[i])
maxSum = max(maxSum, currentSum)

Steps:
Initialize currentSum = 0, maxSum = nums[0]
Iterate each element:
currentSum = max(nums[i], currentSum + nums[i])
maxSum = max(maxSum, currentSum)
Return maxSum


code:
class Solution{
public:
    int maxSubArray(vector<int>& nums){
        int currentsum=0;
        int maxsum=nums[0];
        for(int num:nums){
            currentsum=max(num,currentsum+num);
            maxsum=max(maxsum,currentsum);
        }
        return maxsum;
    }
};



Dry Run
nums = [-2,1,-3,4,-1,2,1,-5,4]
currentSum=0, maxSum=-2

i=0: num=-2 → currentSum=max(-2,0-2)=-2 → maxSum=-2
i=1: num=1 → currentSum=max(1,-2+1)=1 → maxSum=1
i=2: num=-3 → currentSum=max(-3,1-3)=-2 → maxSum=1
i=3: num=4 → currentSum=max(4,-2+4)=4 → maxSum=4
i=4: num=-1 → currentSum=max(-1,4-1)=3 → maxSum=4
i=5: num=2 → currentSum=max(2,3+2)=5 → maxSum=5
i=6: num=1 → currentSum=max(1,5+1)=6 → maxSum=6
i=7: num=-5 → currentSum=max(-5,6-5)=1 → maxSum=6
i=8: num=4 → currentSum=max(4,1+4)=5 → maxSum=6


Complexity
Time: O(n) → single pass
Space: O(1) → constant space


















































class Solution{
public:
    int maxSubArray(vector<int>& nums){
        int n=nums.size();
        int maxsum=nums[0];
        int currsum=nums[0];
        for(int i=1;i<n;i++){
            currsum=max(nums[i],currsum+nums[i]);
            maxsum=max(maxsum,currsum);
        }
        return maxsum;
    }
};
