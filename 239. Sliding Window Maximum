Approach (Deque - Monotonic Queue):
Use a deque to store indices of elements.
The deque will store elements in decreasing order of values.
The front of the deque always has the index of the current window’s maximum.

For each element:
Remove indices that are out of the current window.
Remove indices from the back if their value is less than current value.
Push current index.
When window size ≥ k, record the max (front of deque).


code:
class Solution{
public:
    vector<int> maxSlidingWindow(vector<int>& nums,int k){
        deque<int> dq;
        vector<int> res;
        for(int i=0;i<nums.size();i++){
            if(!dq.empty() && dq.front()==i-k) dq.pop_front();

            while(!dq.empty() && nums[dq.back()]<nums[i]) dq.pop_back();

            dq.push_back(i);

            if(i>=k-1) res.push_back(nums[dq.front()]);
        }
        return res;
    }
};



Dry Run
Input: nums = [1,3,-1,-3,5,3,6,7], k=3
Window [1,3,-1] → max=3
Window [3,-1,-3] → max=3
Window [-1,-3,5] → max=5
Window [-3,5,3] → max=5
Window [5,3,6] → max=6
Window [3,6,7] → max=7
Output: [3,3,5,5,6,7]


Complexity
Time: O(n) (each element pushed & popped at most once)
Space: O(k)
