Approach (Modified Binary Search)
Use binary search with mid.
At each step:
If nums[mid] == target → return mid.
Decide which half is sorted:
If nums[left] <= nums[mid] → left half is sorted.
Check if target lies in this half. If yes, move right to mid-1, else left=mid+1.
Else → right half is sorted.
Check if target lies in this half. If yes, move left to mid+1, else right=mid-1.
If not found, return -1.


code:
class Solution{
public:
    int search(vector<int>& nums,int target){
        int left=0,right=nums.size()-1;

        while(left<=right){
            int mid=left+(right-left)/2;

            if(nums[mid]==target) return mid;

            if(nums[left]<=nums[mid]){
                if(nums[left]<=target && target<nums[mid]){
                    right=mid-1;
                }else{
                    left=mid+1;
                }
            }else{
                if(nums[mid]<target && target<=nums[right]){
                    left=mid+1;
                }else{
                    right=mid-1;
                }
            }
        }
        return -1;
    }
};




Dry Run
Input: nums=[4,5,6,7,0,1,2], target=0
left=0, right=6 → mid=3 → nums[3]=7
left half [4,5,6,7] sorted → but 0 not in this range → search right.
left=4, right=6 → mid=5 → nums[5]=1
right half [1,2] sorted → but target=0 not in this range → search left.
left=4, right=4 → mid=4 → nums[4]=0  found.
Output = 4



Complexity
Time: O(log n)
Space: O(1)
