Idea: Precompute next greater for every element in nums2 using a monotonic decreasing stack; store results in a hashmap; then answer queries for nums1.
Steps
Iterate nums2 left â†’ right.
Maintain a stack of elements (values) in strictly decreasing order.
For current x, while stack not empty and x > stack.top(), pop t and set nextGreater[t] = x.
Push x on stack.
After loop, remaining stack elements have -1.
For each num in nums1, output nextGreater[num].


code:
class Solution{
public:
    vector<int> nextGreaterElement(vector<int>& nums1,vector<int>& nums2){
        unordered_map<int,int> nextGreater;
        stack<int> st;

        for(int x:nums2){
            while(!st.empty() && x>st.top()){
                nextGreater[st.top()]=x;
                st.pop();
            }
            st.push(x);
        }
        while(!st.empty()){
            nextGreater[st.top()]=-1;
            st.pop();
        }
        vector<int> res;
        res.reserve(nums1.size());
        for(int x:nums1) res.push_back(nextGreater[x]);
        return res;
    }
};



Dry run
nums1 = [4,1,2], nums2 = [1,3,4,2]
Process 1 -> st:[1]
Process 3 -> pop 1 -> next[1]=3 ; st:[3]
Process 4 -> pop 3 -> next[3]=4 ; st:[4]
Process 2 -> st:[4,2]
Finish -> next[4] = -1, next[2] = -1
Answer for nums1: [next[4], next[1], next[2]] = [-1,3,-1]


Complexity
Time: O(n2 + n1) overall O(n2) where n2 = nums2 length (each element pushed/popped once)
Space: O(n2) for map + stack
