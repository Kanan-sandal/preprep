Approach (Expand Around Center, Optimal)
Same as above, but instead of counting, we track longest substring length & start index.


Explanation of Key Logic
 1. Why 2*n - 1 centers?
A palindrome can be centered on:
A character itself (odd length palindrome, e.g. "aba").
A gap between two characters (even length palindrome, e.g. "abba").
For a string of length n, there are n character-centers + n-1 gaps = 2n-1 total centers.



code:
class Solution{
public:
    int countSubstrings(string s){
        int n=s.size();
        int count=0;
        for(int center=0;center<2*n-1;center++){
            int left=center/2;
            int right=left+center%2;

            while(left>=0 && right<n && s[left]==s[right]){
                count++;
                left--;
                right++;
            }
        }
        return count;
    }
};



Dry Run
s = "babad"
Center 0 (b): odd → "b".
Center 1 (a): odd → "aba" (len 3).
Center 2 (b): odd → "bab" (len 3).
Longest found = "bab" (or "aba").


Complexity
Time: O(n²)
Space: O(1)





How do we calculate left and right?
left = center/2
right = left + center%2
If center is even, both left and right point to same char (odd length palindrome).
If center is odd, right = left+1 → gap between two chars (even length palindrome).



3. Expansion
From each center, expand outwards (left--, right++) while characters match.
Each time we expand successfully, we count a new palindrome.



Dry Run Example: "aaa"
n = 3, so 2n-1 = 5 centers.
center=0 → (left=0,right=0)
expand "a" → count=1
center=1 → (left=0,right=1)
expand "aa" → count=2
center=2 → (left=1,right=1)
expand "a" → count=3
expand "aaa" → count=4
center=3 → (left=1,right=2)
expand "aa" → count=5
center=4 → (left=2,right=2)
expand "a" → count=6
Answer = 6



Complexity
Time: O(n²) (in worst case like "aaaaa" every expansion works).
Space: O(1)
