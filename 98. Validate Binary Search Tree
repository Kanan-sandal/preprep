Approach
Use recursion with range limits (min, max).
At each node:
Check if min < node->val < max.
Recurse left with (min, node->val) and right with (node->val, max).

code:
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution{
public:
    bool isValidBST(TreeNode* root){
        return validate(root,LONG_MIN,LONG_MAX);
    }
private:
    bool validate(TreeNode* node,long minval,long maxval){
        if(!node) return true;
        if(node->val<=minval || node->val>=maxval) return false;
        return validate(node->left,minval,node->val)&&
               validate(node->right,node->val,maxval);
    }
};



Dry Run
Input Tree (Valid BST):

      2
     / \
    1   3


validate(2, -∞, ∞) ✅
validate(1, -∞, 2) ✅
validate(3, 2, ∞) ✅
All valid → return true.

Invalid BST Example:

      5
     / \
    1   4
       / \
      3   6


validate(5, -∞, ∞) ✅
validate(1, -∞, 5) ✅
validate(4, 5, ∞) ❌ → fails because 4 ≤ 5.
Output: false.













































/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution{
public:
    bool isValidBST(TreeNode* node){
        return validate(node,LONG_MIN,LONG_MAX);
    }
    bool validate(TreeNode* node,long minval,long maxval){
        if(!node) return true;
        if(node->val<=minval || node->val>=maxval) return false;
        return validate(node->left,minval,node->val)&&
        validate(node->right,node->val,maxval);
    }
};


Complexity
Time: O(n) (check each node once).
Space: O(h) recursion stack.
