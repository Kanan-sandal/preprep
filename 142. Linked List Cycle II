We donâ€™t just detect a cycle â€” we must find the starting node of the cycle.
Approach (Floydâ€™s + Reset Trick)
Step 1: Use Floydâ€™s algorithm to detect the cycle (same as above).
Step 2: Once slow == fast, reset one pointer to head.
Step 3: Move both slow and fast one step at a time â†’ theyâ€™ll meet at the cycle start.


code:
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution{
public:
    ListNode* detectCycle(ListNode* head){
        if(!head || !head->next) return NULL;
        ListNode* slow=head;
        ListNode* fast=head;
        bool hascycle=false;
        while(fast && fast->next){
            slow=slow->next;
            fast=fast->next->next;
            if(slow==fast){
                hascycle=true;
                break;
            }
        }
        if(!hascycle) return NULL;

        slow=head;
        while(slow!=fast){
            slow=slow->next;
            fast=fast->next;
        }
        return slow;
    }
};


Input:
1 â†’ 2 â†’ 3 â†’ 4 â†’ 5 â†’ 3 (cycle starts at node 3)
Steps:
Step 1: Detect cycle
slow=1, fast=1
Iter 1: slow=2, fast=3
Iter 2: slow=3, fast=5
Iter 3: slow=4, fast=4 âœ… meet â†’ cycle detected.
Step 2: Find cycle start
Reset slow = head (1), fast = meeting point (4).
Iter 1: slow=2, fast=5
Iter 2: slow=3, fast=3 âœ… meet again at 3 (cycle start).
Output: node with value 3.


â±ï¸ Time: O(n)
ðŸ“¦ Space: O(1)









































/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution{
public:
    ListNode* detectCycle(ListNode* head){
        if(!head || !head->next) return NULL;
        ListNode* slow=head;
        ListNode* fast=head;
        while(fast && fast->next){
            slow=slow->next;
            fast=fast->next->next;
            if(slow==fast){
                slow=head;
                while(slow!=fast){
                    slow=slow->next;
                    fast=fast->next;
                }
                return slow;
            }
        }
        return NULL;
    }
};
