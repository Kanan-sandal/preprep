Optimal Approach (Two Pointers)
Idea:
Water trapped at index i depends on:
water[i] = min(maxLeft[i], maxRight[i]) - height[i]
Instead of precomputing, use two pointers (l and r) with running leftMax and rightMax.
Steps:
Initialize l=0, r=n-1, leftMax=0, rightMax=0, res=0
While l<r:
If height[l] < height[r]:
If height[l] >= leftMax → update leftMax
Else → add leftMax - height[l] to res
Move l++
Else:
If height[r] >= rightMax → update rightMax
Else → add rightMax - height[r]
Move r--


code:
class Solution{
public:
    int trap(vector<int>& height){
        int n=height.size();
        int l=0,r=n-1;
        int leftmax=0,rightmax=0;
        int res=0;

        while(l<r){
            if(height[l]<height[r]){
                if(height[l]>=leftmax) leftmax=height[l];
                else res+=leftmax-height[l];
                l++;
            }else{
                if(height[r]>=rightmax) rightmax=height[r];
                else res+=rightmax-height[r];
                r--;
            }
        }
        return res;
    }
};



Dry Run
height = [0,1,0,2,1,0,1,3,2,1,2,1]
l=0,r=11, leftMax=0,rightMax=0,res=0
step: l=0 → height[l]=0 < height[r]=1
       leftMax=0 → res+=0-0=0 → l=1
step: l=1 → height=1 <1? no (go right)
       rightMax=1 → r=10
step: l=1,r=10 → height[l]=1<height[r]=2
       leftMax=1 → l=2
step: l=2 → height=0 <2
       res+=1-0=1 → l=3
step: l=3 → height=2 <2? no
...
Continue → final res=6
Output: 6



Complexity
Time: O(n) → single pass
Space: O(1) → constant space
