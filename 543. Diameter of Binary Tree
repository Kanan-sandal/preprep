Approach
Diameter at a node = left height + right height.
Compute height recursively, while updating a global maxDiameter.


Code Explanation
diameter → keeps track of the max path length seen so far.
depth(root):
returns the height of the subtree rooted at root.
recursively computes:
left = depth(root->left)
right = depth(root->right)
updates diameter = max(diameter, left + right)
(because a path through this node can go left → root → right).
returns 1 + max(left, right) (height of current subtree).
diameterOfBinaryTree(root) → just calls DFS and returns the global diameter.


code:
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution{
public:
    int depth(TreeNode* root,int &diameter){
        if(!root) return 0;
        int left=depth(root->left,diameter);
        int right=depth(root->right,diameter);
        diameter=max(diameter,left+right);
        return 1+max(left,right);
    }
    int diameterOfBinaryTree(TreeNode* root){
        int diameter=0;
        depth(root,diameter);
        return diameter;
    }
};



Dry Run (first approach, reference version)
Tree:

    1
   / \
  2   3
 / \
4   5


Start: diameter = 0
Node 4: depth=1, diameter=max(0,0)=0
Node 5: depth=1, diameter=0
Node 2: depth=2, diameter=max(0,1+1=2)=2
Node 3: depth=1, diameter=2
Node 1: depth=3, diameter=max(2,2+1=3)=3
Final diameter=3.


⏱ Complexity
Time: O(n) → each node visited once.
Space: O(h) → recursion stack (h = tree height, worst O(n), best O(log n) for balanced tree).
