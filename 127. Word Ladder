Brute Force Idea
Try all possible paths using DFS:
At each word, change every letter to all 26 possibilities.
If that new word exists in wordList and not visited, recurse.

Problem:
→ Huge branching factor → exponential time (O(26ⁿ)) 
⚡ Optimal Solution → BFS (Shortest Path in Unweighted Graph)


Intuition:
Treat each word as a node.
Draw an edge between two words if they differ by exactly one letter.
Then the question becomes:
➤ Find the shortest path from beginWord → endWord.
Shortest path in unweighted graph = BFS.


Algorithm
Put all words in a hash set for O(1) lookups.
Start BFS with queue containing {beginWord, level=1}.
For each word in queue:
Try changing each character (‘a’–‘z’).
If new word exists in set, push it into queue and remove it (mark visited).
When we find endWord, return level + 1.
If BFS ends → return 0.


Time & Space Complexity
Each word of length L, dictionary of size N.
For each word → O(26×L) transformations.
Each transformation checked once.
Time: O(N × L × 26) ≈ O(N × L)
Space: O(N) for queue + set.



code:
class Solution{
public:
    int ladderLength(string beginWord,string endWord,vector<string>& wordList){
        unordered_set<string> wordSet(wordList.begin(),wordList.end());
        if(wordSet.find(endWord)==wordSet.end()) return 0;

        queue<pair<string,int>> q;
        q.push({beginWord,1});

        while(!q.empty()){
            auto[word,level]=q.front();q.pop();
            if(word==endWord) return level;

            for(int i=0;i<word.size();i++){
                string temp=word;

                for(char c='a';c<='z';c++){
                    temp[i]=c;

                    if(wordSet.find(temp)!=wordSet.end()){
                        q.push({temp,level+1});
                        wordSet.erase(temp);
                    }
                }
            }
        }
        return 0;
    }
};




Dry Run
Input:
beginWord = "hit"
endWord = "cog"
wordList = ["hot","dot","dog","lot","log","cog"]

Step-by-step BFS:
Level 1: "hit"
 → "hot" (in wordList) → push → erase "hot"

Level 2: "hot"
 → "dot", "lot" → push both → erase

Level 3: "dot", "lot"
 → "dog" (from dot), "log" (from lot)

Level 4: "dog", "log"
 → "cog" (from dog) found at level 5


Answer = 5
